import { FACE_MOVEMENT_AND_LIGHT_CHALLENGE, FACE_MOVEMENT_CHALLENGE } from './constants.mjs';

const isFaceMovementAndLightChallenge = (value) => {
    return (value?.Challenge?.Name ===
        'FaceMovementAndLightChallenge');
};
const isFaceMovementChallenge = (value) => {
    return (value?.Challenge?.Name ===
        'FaceMovementChallenge');
};
const isFaceMovementAndLightServerChallenge = (value) => {
    return !!value
        ?.FaceMovementAndLightChallenge;
};
const isFaceMovementServerChallenge = (value) => {
    return !!value
        ?.FaceMovementChallenge;
};
const createSessionInfoFromServerSessionInformation = (serverSessionInformation) => {
    let challenge;
    if (isFaceMovementAndLightServerChallenge(serverSessionInformation.Challenge)) {
        challenge = {
            ...serverSessionInformation.Challenge.FaceMovementAndLightChallenge,
            Name: FACE_MOVEMENT_AND_LIGHT_CHALLENGE.type,
        };
    }
    else if (isFaceMovementServerChallenge(serverSessionInformation.Challenge)) {
        challenge = {
            ...serverSessionInformation.Challenge.FaceMovementChallenge,
            Name: FACE_MOVEMENT_CHALLENGE.type,
        };
    }
    else {
        throw new Error('Unsupported challenge type returned from session information.');
    }
    if (!challenge.ChallengeConfig ||
        !challenge.ChallengeConfig.FaceDistanceThreshold ||
        !challenge.ChallengeConfig.FaceDistanceThresholdMin ||
        !challenge.ChallengeConfig.OvalHeightWidthRatio) {
        throw new Error('Challenge config not returned from session information.');
    }
    return { ...serverSessionInformation, Challenge: challenge };
};

export { createSessionInfoFromServerSessionInformation, isFaceMovementAndLightChallenge, isFaceMovementAndLightServerChallenge, isFaceMovementChallenge, isFaceMovementServerChallenge };
