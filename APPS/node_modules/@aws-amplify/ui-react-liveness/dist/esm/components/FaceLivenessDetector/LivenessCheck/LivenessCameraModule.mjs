import React__default, { useRef, useState } from 'react';
import { classNames } from '@aws-amplify/ui';
import { View, Flex, Loader, Text, Button } from '@aws-amplify/ui-react';
import { useColorMode } from '@aws-amplify/ui-react/internal';
import '../service/machine/machine.mjs';
import { FaceMatchState } from '../service/types/liveness.mjs';
import '@tensorflow/tfjs-core';
import '../../../node_modules/@tensorflow-models/face-detection/dist/face-detection.esm.mjs';
import '@tensorflow/tfjs-backend-wasm';
import '@tensorflow/tfjs-backend-cpu';
import '@aws-amplify/core/internals/utils';
import { drawStaticOval, clearOvalCanvas } from '../service/utils/liveness.mjs';
import { FACE_MOVEMENT_CHALLENGE } from '../service/utils/constants.mjs';
import '../service/utils/ColorSequenceDisplay/ColorSequenceDisplay.mjs';
import '../service/utils/createStreamingClient/createStreamingClient.mjs';
import '../service/utils/StreamRecorder/StreamRecorder.mjs';
import { useLivenessActor } from '../hooks/useLivenessActor.mjs';
import { useLivenessSelector, createLivenessSelector } from '../hooks/useLivenessSelector.mjs';
import { useMediaStreamInVideo } from '../hooks/useMediaStreamInVideo.mjs';
import { LivenessClassNames } from '../types/classNames.mjs';
import { selectErrorState, Hint } from '../shared/Hint.mjs';
import { MatchIndicator } from '../shared/MatchIndicator.mjs';
import { Overlay } from '../shared/Overlay.mjs';
import { isDeviceUserFacing } from '../utils/device.mjs';
import { FaceLivenessErrorModal, renderErrorModal } from '../shared/FaceLivenessErrorModal.mjs';
import { DefaultPhotosensitiveWarning, DefaultRecordingIcon, DefaultCancelButton } from '../shared/DefaultStartScreenComponents.mjs';
import { CameraSelector } from './CameraSelector.mjs';

const selectChallengeType = createLivenessSelector((state) => state.context.parsedSessionInformation?.Challenge?.Name);
const selectVideoConstraints = createLivenessSelector((state) => state.context.videoAssociatedParams?.videoConstraints);
const selectVideoStream = createLivenessSelector((state) => state.context.videoAssociatedParams?.videoMediaStream);
const selectFaceMatchPercentage = createLivenessSelector((state) => state.context.faceMatchAssociatedParams?.faceMatchPercentage);
const selectFaceMatchState = createLivenessSelector((state) => state.context.faceMatchAssociatedParams?.faceMatchState);
const selectSelectedDeviceId = createLivenessSelector((state) => state.context.videoAssociatedParams?.selectedDeviceId);
const selectSelectableDevices = createLivenessSelector((state) => state.context.videoAssociatedParams?.selectableDevices);
const showMatchIndicatorStates = [
    FaceMatchState.TOO_FAR,
    FaceMatchState.CANT_IDENTIFY,
    FaceMatchState.FACE_IDENTIFIED,
    FaceMatchState.OFF_CENTER,
];
/**
 * For now we want to memoize the HOC for MatchIndicator because to optimize renders
 * The LivenessCameraModule still needs to be optimized for re-renders and at that time
 * we should be able to remove this memoization
 */
const MemoizedMatchIndicator = React__default.memo(MatchIndicator);
const LivenessCameraModule = (props) => {
    const { isMobileScreen, isRecordingStopped, instructionDisplayText, streamDisplayText, hintDisplayText, errorDisplayText, cameraDisplayText, components: customComponents, testId, } = props;
    const { cancelLivenessCheckText, recordingIndicatorText } = streamDisplayText;
    const { ErrorView = FaceLivenessErrorModal, PhotosensitiveWarning = DefaultPhotosensitiveWarning, } = customComponents ?? {};
    const [state, send] = useLivenessActor();
    const isFaceMovementChallenge = useLivenessSelector(selectChallengeType) === FACE_MOVEMENT_CHALLENGE.type;
    const videoStream = useLivenessSelector(selectVideoStream);
    const videoConstraints = useLivenessSelector(selectVideoConstraints);
    const selectedDeviceId = useLivenessSelector(selectSelectedDeviceId);
    const selectableDevices = useLivenessSelector(selectSelectableDevices);
    const faceMatchPercentage = useLivenessSelector(selectFaceMatchPercentage);
    const faceMatchState = useLivenessSelector(selectFaceMatchState);
    const errorState = useLivenessSelector(selectErrorState);
    const colorMode = useColorMode();
    const { videoRef, videoWidth, videoHeight } = useMediaStreamInVideo(videoStream);
    const canvasRef = useRef(null);
    const freshnessColorRef = useRef(null);
    const [isCameraReady, setIsCameraReady] = useState(false);
    const [isMetadataLoaded, setIsMetadataLoaded] = useState(false);
    const [isCameraUserFacing, setIsCameraUserFacing] = useState(true);
    const isInitCamera = state.matches('initCamera');
    const isInitWebsocket = state.matches('initWebsocket');
    const isCheckingCamera = state.matches({ initCamera: 'cameraCheck' });
    const isWaitingForCamera = state.matches({
        initCamera: 'waitForDOMAndCameraDetails',
    });
    const isStartView = state.matches('start') || state.matches('userCancel');
    const isDetectFaceBeforeStart = state.matches('detectFaceBeforeStart');
    const isRecording = state.matches('recording');
    const isCheckSucceeded = state.matches('checkSucceeded');
    const isFlashingFreshness = state.matches({
        recording: 'flashFreshnessColors',
    });
    // Android/Firefox and iOS flip the values of width/height returned from
    // getUserMedia, so we'll reset these in useLayoutEffect with the videoRef
    // element's intrinsic videoWidth and videoHeight attributes
    const [mediaWidth, setMediaWidth] = useState(videoWidth);
    const [mediaHeight, setMediaHeight] = useState(videoHeight);
    const [aspectRatio, setAspectRatio] = useState(() => videoWidth && videoHeight ? videoWidth / videoHeight : 0);
    // Only mobile device camera selection for no light challenge
    const hasMultipleDevices = !!selectableDevices?.length && selectableDevices.length > 1;
    const allowDeviceSelection = isStartView &&
        hasMultipleDevices &&
        (!isMobileScreen || isFaceMovementChallenge);
    React__default.useEffect(() => {
        async function checkCameraFacing() {
            const isUserFacing = await isDeviceUserFacing(selectedDeviceId);
            setIsCameraUserFacing(isUserFacing);
        }
        checkCameraFacing();
    }, [selectedDeviceId]);
    React__default.useEffect(() => {
        const shouldDrawOval = canvasRef?.current &&
            videoRef?.current &&
            videoStream &&
            isStartView &&
            isMetadataLoaded;
        if (shouldDrawOval) {
            drawStaticOval(canvasRef.current, videoRef.current, videoStream);
        }
        const updateColorModeHandler = (e) => {
            if (e.matches && shouldDrawOval) {
                drawStaticOval(canvasRef.current, videoRef.current, videoStream);
            }
        };
        const darkModePreference = window.matchMedia('(prefers-color-scheme: dark)');
        const lightModePreference = window.matchMedia('(prefers-color-scheme: light)');
        darkModePreference.addEventListener('change', updateColorModeHandler);
        lightModePreference.addEventListener('change', updateColorModeHandler);
        return () => {
            darkModePreference.removeEventListener('change', updateColorModeHandler);
            lightModePreference.addEventListener('change', updateColorModeHandler);
        };
    }, [videoRef, videoStream, colorMode, isStartView, isMetadataLoaded]);
    React__default.useLayoutEffect(() => {
        if (isCameraReady) {
            send({
                type: 'SET_DOM_AND_CAMERA_DETAILS',
                data: {
                    videoEl: videoRef.current,
                    canvasEl: canvasRef.current,
                    freshnessColorEl: freshnessColorRef.current,
                    isMobile: isMobileScreen,
                },
            });
        }
        if (videoRef.current) {
            setMediaWidth(videoRef.current.videoWidth);
            setMediaHeight(videoRef.current.videoHeight);
            setAspectRatio(videoRef.current.videoWidth / videoRef.current.videoHeight);
        }
    }, [send, videoRef, isCameraReady, isMobileScreen]);
    React__default.useEffect(() => {
        if (isDetectFaceBeforeStart) {
            clearOvalCanvas({ canvas: canvasRef.current });
        }
    }, [isDetectFaceBeforeStart]);
    const photoSensitivityWarning = React__default.useMemo(() => {
        return (React__default.createElement(View, { style: { visibility: isStartView ? 'visible' : 'hidden' } },
            React__default.createElement(PhotosensitiveWarning, { bodyText: instructionDisplayText.photosensitivityWarningBodyText, headingText: instructionDisplayText.photosensitivityWarningHeadingText, infoText: instructionDisplayText.photosensitivityWarningInfoText, labelText: instructionDisplayText.photosensitivityWarningLabelText })));
    }, [PhotosensitiveWarning, instructionDisplayText, isStartView]);
    const handleMediaPlay = () => {
        setIsCameraReady(true);
    };
    const handleLoadedMetadata = () => {
        setIsMetadataLoaded(true);
    };
    const beginLivenessCheck = React__default.useCallback(() => {
        send({
            type: 'BEGIN',
        });
    }, [send]);
    const onCameraChange = React__default.useCallback((e) => {
        const newDeviceId = e.target.value;
        const changeCamera = async () => {
            setIsMetadataLoaded(false);
            const newStream = await navigator.mediaDevices.getUserMedia({
                video: {
                    ...videoConstraints,
                    deviceId: { exact: newDeviceId },
                },
                audio: false,
            });
            send({
                type: 'UPDATE_DEVICE_AND_STREAM',
                data: { newDeviceId, newStream },
            });
        };
        changeCamera();
    }, [videoConstraints, send]);
    if (isCheckingCamera) {
        return (React__default.createElement(Flex, { justifyContent: 'center', className: LivenessClassNames.StartScreenCameraWaiting },
            React__default.createElement(Loader, { size: "large", className: LivenessClassNames.CenteredLoader, "data-testid": "centered-loader", position: "unset" }),
            React__default.createElement(Text, { fontSize: "large", fontWeight: "bold", "data-testid": "waiting-camera-permission", className: `${LivenessClassNames.StartScreenCameraWaiting}__text` }, cameraDisplayText.waitingCameraPermissionText)));
    }
    const shouldShowCenteredLoader = isInitCamera || isInitWebsocket;
    // We don't show full screen camera on the pre check screen (isStartView/isWaitingForCamera)
    const shouldShowFullScreenCamera = isMobileScreen && !isStartView && !shouldShowCenteredLoader;
    return (React__default.createElement(React__default.Fragment, null,
        !isFaceMovementChallenge && photoSensitivityWarning,
        shouldShowCenteredLoader && (React__default.createElement(Flex, { className: LivenessClassNames.ConnectingLoader },
            React__default.createElement(Loader, { size: "large", className: LivenessClassNames.Loader, "data-testid": "centered-loader" }),
            React__default.createElement(Text, { className: LivenessClassNames.LandscapeErrorModalHeader }, hintDisplayText.hintConnectingText))),
        React__default.createElement(Flex, { className: classNames(LivenessClassNames.CameraModule, shouldShowFullScreenCamera &&
                `${LivenessClassNames.CameraModule}--mobile`), "data-testid": testId, gap: "zero" },
            React__default.createElement(Overlay, { horizontal: "center", vertical: isRecording && !isFlashingFreshness ? 'start' : 'space-between', className: LivenessClassNames.InstructionOverlay },
                isRecording && (React__default.createElement(DefaultRecordingIcon, { recordingIndicatorText: recordingIndicatorText })),
                !isStartView && !isWaitingForCamera && !isCheckSucceeded && (React__default.createElement(DefaultCancelButton, { cancelLivenessCheckText: cancelLivenessCheckText })),
                React__default.createElement(Flex, { className: classNames(LivenessClassNames.Hint, shouldShowFullScreenCamera && `${LivenessClassNames.Hint}--mobile`) },
                    React__default.createElement(Hint, { hintDisplayText: hintDisplayText })),
                errorState && (React__default.createElement(ErrorView, { onRetry: () => {
                        send({ type: 'CANCEL' });
                    }, displayText: errorDisplayText }, renderErrorModal({
                    errorState,
                    overrideErrorDisplayText: errorDisplayText,
                }))),
                isRecording &&
                    !isFlashingFreshness &&
                    showMatchIndicatorStates.includes(faceMatchState) ? (React__default.createElement(MemoizedMatchIndicator, { percentage: Math.ceil(faceMatchPercentage) })) : null),
            React__default.createElement(View, { as: "canvas", ref: freshnessColorRef, className: LivenessClassNames.FreshnessCanvas, hidden: true }),
            React__default.createElement(View, { className: LivenessClassNames.VideoAnchor, style: {
                    aspectRatio: `${aspectRatio}`,
                } },
                React__default.createElement("video", { ref: videoRef, muted: true, autoPlay: true, playsInline: true, width: mediaWidth, height: mediaHeight, onCanPlay: handleMediaPlay, onLoadedMetadata: handleLoadedMetadata, "data-testid": "video", className: classNames(LivenessClassNames.Video, isCameraUserFacing && LivenessClassNames.UserFacingVideo, isRecordingStopped && LivenessClassNames.FadeOut), "aria-label": cameraDisplayText.a11yVideoLabelText }),
                React__default.createElement(Flex, { className: classNames(LivenessClassNames.OvalCanvas, shouldShowFullScreenCamera &&
                        `${LivenessClassNames.OvalCanvas}--mobile`, isRecordingStopped && LivenessClassNames.FadeOut) },
                    React__default.createElement(View, { as: "canvas", ref: canvasRef })),
                allowDeviceSelection ? (React__default.createElement(CameraSelector, { onSelect: onCameraChange, devices: selectableDevices, deviceId: selectedDeviceId })) : null)),
        isStartView && (React__default.createElement(Flex, { justifyContent: "center" },
            React__default.createElement(Button, { variation: "primary", type: "button", onClick: beginLivenessCheck }, instructionDisplayText.startScreenBeginCheckText)))));
};

export { LivenessCameraModule, selectChallengeType, selectFaceMatchPercentage, selectFaceMatchState, selectSelectableDevices, selectSelectedDeviceId, selectVideoConstraints, selectVideoStream };
