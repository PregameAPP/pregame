import { isUndefined } from '@aws-amplify/ui';
import { isFaceMovementChallenge, isFaceMovementAndLightChallenge } from '../sessionInformation.mjs';

const createVideoEvent = async (result) => {
    const { data, type } = result;
    return {
        VideoChunk: new Uint8Array(
        // server expects an empty chunk on 'stopStream' event
        type === 'streamVideo' ? await data.arrayBuffer() : []),
        // @ts-expect-error for 'closeCode' event, `data` is an object which is
        // unexpected by `VideoEvent` but is expected by the streaming service
        TimestampMillis: type === 'closeCode' ? data : Date.now(),
    };
};
const getTrackDimensions = (stream) => {
    const { height: trackHeight, width: trackWidth } = stream
        .getVideoTracks()[0]
        .getSettings();
    if (isUndefined(trackHeight) || isUndefined(trackWidth)) {
        throw new Error(`Invalid Track Dimensions. height: ${trackHeight}, width: ${trackWidth} `);
    }
    return { trackHeight, trackWidth };
};
function getBoundingBox({ trackHeight, trackWidth, height, width, top, left, }) {
    return {
        Height: height / trackHeight,
        Width: width / trackWidth,
        Top: top / trackHeight,
        Left: left / trackWidth,
    };
}
const getFlippedInitialFaceLeft = (trackWidth, faceLeft, faceWidth) => trackWidth - faceLeft - faceWidth;
const getInitialFaceBoundingBox = (params) => {
    const { trackWidth, left, width } = params;
    return getBoundingBox({
        ...params,
        left: getFlippedInitialFaceLeft(trackWidth, left, width),
    });
};
const getTargetFaceBoundingBox = (params) => {
    const { height, width, centerX, centerY } = params;
    return getBoundingBox({
        ...params,
        top: centerY - height / 2,
        left: centerX - width / 2,
    });
};
function createClientSessionInformationEvent({ parsedSessionInformation, clientChallenge, }) {
    if (isFaceMovementChallenge(parsedSessionInformation)) {
        return {
            Challenge: {
                FaceMovementChallenge: clientChallenge,
            },
        };
    }
    if (isFaceMovementAndLightChallenge(parsedSessionInformation)) {
        return {
            Challenge: {
                FaceMovementAndLightChallenge: clientChallenge,
            },
        };
    }
    throw new Error('Unable to create ClientSessionInformationEvent');
}
function createSessionEndEvent({ parsedSessionInformation, challengeId, faceMatchAssociatedParams, ovalAssociatedParams, recordingEndedTimestamp, trackHeight, trackWidth, }) {
    const { initialFace, ovalDetails } = ovalAssociatedParams;
    const { startFace, endFace } = faceMatchAssociatedParams;
    const initialFaceBoundingBox = getInitialFaceBoundingBox({
        trackHeight,
        trackWidth,
        ...initialFace,
    });
    const targetFaceBoundingBox = getTargetFaceBoundingBox({
        trackHeight,
        trackWidth,
        ...ovalDetails,
    });
    const clientChallenge = {
        ChallengeId: challengeId,
        InitialFace: {
            InitialFaceDetectedTimestamp: initialFace.timestampMs,
            BoundingBox: initialFaceBoundingBox,
        },
        TargetFace: {
            FaceDetectedInTargetPositionStartTimestamp: startFace.timestampMs,
            FaceDetectedInTargetPositionEndTimestamp: endFace.timestampMs,
            BoundingBox: targetFaceBoundingBox,
        },
        VideoEndTimestamp: recordingEndedTimestamp,
    };
    return createClientSessionInformationEvent({
        parsedSessionInformation,
        clientChallenge,
    });
}
function createSessionStartEvent({ parsedSessionInformation, challengeId, ovalAssociatedParams, recordingStartedTimestamp, trackHeight, trackWidth, }) {
    const { initialFace } = ovalAssociatedParams;
    const initialFaceBoundingBox = getInitialFaceBoundingBox({
        trackHeight,
        trackWidth,
        ...initialFace,
    });
    const clientChallenge = {
        ChallengeId: challengeId,
        VideoStartTimestamp: recordingStartedTimestamp,
        InitialFace: {
            InitialFaceDetectedTimestamp: initialFace.timestampMs,
            BoundingBox: initialFaceBoundingBox,
        },
    };
    return createClientSessionInformationEvent({
        parsedSessionInformation,
        clientChallenge,
    });
}
/**
 * Translates provided sequence color string to an RGB array
 *
 * @param {SequenceColorValue} color
 * @returns {number[]}
 */
const colorToRgb = (color) => {
    return color
        .slice(color.indexOf('(') + 1, color.indexOf(')'))
        .split(',')
        .map((str) => parseInt(str));
};
function createColorDisplayEvent({ challengeId, sequenceStartTime, sequenceIndex, sequenceColor, prevSequenceColor, }) {
    const CurrentColor = { RGB: colorToRgb(sequenceColor) };
    const PreviousColor = {
        RGB: colorToRgb(prevSequenceColor),
    };
    return {
        Challenge: {
            FaceMovementAndLightChallenge: {
                ChallengeId: challengeId,
                ColorDisplayed: {
                    CurrentColor,
                    PreviousColor,
                    SequenceNumber: sequenceIndex,
                    CurrentColorStartTimestamp: sequenceStartTime,
                },
            },
        },
    };
}

export { createColorDisplayEvent, createSessionEndEvent, createSessionStartEvent, createVideoEvent, getTrackDimensions };
